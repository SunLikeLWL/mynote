# 浏览器原理


### cpu

中央处理器，可以串行的处理任务

每一个核心都是独立的cpu单元组



### GPU

图形处理器，每一个GPU的核心只处理一些简单的任务，但是核心数量非常多，也就是说并行计算的能力非常强




### 线程& 进程


进程-可以看做是一个正在运行的应用程序

线程-运行在进程里面，一个进程里会有一个或多个线程


当启动一个程序的时候，操作系统至少会为其创建一个进程，
还会为这个进程分配一块独立的内存空间，这块内存存储相关的数据或者状态


redis

当关闭应用的时候，操作系统会把对杨哥呢的进程结束，内存空间也会被释放掉



进程与进程之间，是相互独立的，



### 谷歌浏览器架构


#### Browser Process
只有一个进程，浏览器进程，负责浏览器的主题部分，包括导航栏，书签，前进后退...


#### Network Process
只有一个，网络进程，负责网络资源加载


#### UI Process

#### Storage Process

#### Device Process

#### Render Process
每一个tag就是一个进程，渲染进程，负责tag内和网页展示的相关工作，比如html，js，css
等资源的转换为用户可以与之交互并且看得懂的网页，默认情况下，每一个tab都有一个进程

#### Plugin Process
多个，插件进程，每个插件一个进程


#### GPU Process
只有一个，图像渲染进程，负责渲染





### 多进程架构好处


#### 1、容错性

Chrome会为每一个tab分配一个渲染进程，其中一个标签页挂掉不会影响其他的标签页，

其中一个渲染进程挂掉，不会影响其他渲染进程

如果所有的tab页面都运行在同一个渲染进程里面，其中一个标签页挂掉会影响其他的标签页，


#### 2、安全性


通过操作系统可以给进程赋予各种权限的原理，浏览器可以让某些进程不具备特定的功能

比如渲染进程，chrome限制了他对文件的读写能力


#### 3、每个进程可以拥有更多内存

因为进程在分配的时候，会有一块独立的内存地址空间



### 多进程架构坏处


#### 1、内存占用的问题
每个进程都有自己的内存空间，

v8引擎，是比较基础的东西，会在每个进程的内空间中存在



### 多进程架构的内存优化

默认情况下，每个tab都有一个独立的渲染进程


chrome优化：限制启动得线程的数量。当进程的数量到达某个阈值的时候，Chrome会将访问同一个网站的tab，都放在同一个进程里


-服务化
主要是针对浏览器进程（Browser Process）的优化

高性能的设备上：浏览器进程（Browser Process）会被拆分成各种独立进程，保证各种服务端独立性和安全性

一般的设备上：浏览器进程（Browser Process）


### 网络隔离

网络隔离会为网站内不同的iframe分配一个独立的渲染进程

浏览器会为每个tab分配一个渲染进程，但是如果一个tab内只有一个渲染进程，那么他加载的所有iframe都会共享内存，
意味着这种共享内存的请款袁辉被破坏掉浏览器的同源策略

进程之期的内存空间事绝对相互独立的，做网站隔离是最好的方式其实就是做远程隔离



## 导航的时候发生了什么


浏览器进程（Browser Process），负责各种tab也之外的东西


1、UI线程（UI thread）：绘制浏览器顶部按钮和导航输入框等组件，当你在导航栏输入一些url或者关键字的时候，都是UI线程在处理你的输入


 #### 处理输入

 UI线程要做的第一件事请，就是来确定你输入的是什么类型的内容
 1、search word，会将关键字发送给搜索引擎
 2、url，直接请求你输入的站点资源


 #### 开始导航

 输入完成后，按一下回车

 UI线程会通知网络进程，初始化网络请求来后去站点的内容

 这个时候标签页上的icon会展示一个圈圈正在旋转，网络进程此时会进行各种DNS解析以及建立TLS连接等


-tips 301 302，如果网络进程收到服务器的http状态码是301或者302，他会重新通知UI线程进行重定向，
然后网络进程会再次发起一个新的网络请求



#### 读取响应

1、响应类型判断

Response-header：
Content-Type

但是Content-Type这个响应头不一定存在，浏览器会尝试通过MIME类型嗅探的方式来确定响应类型


2、不同响应类型的处理

-html，浏览器会将获取到的响应数据交给渲染进程，又渲染进程下一步的工作（important）
-zip（文件），响应数据会交给下载管理器来处理


3、安全检查
网络进程在把内容交给渲染进程之前，还会对内容数据做一次安检
如果请求的域名或者响应的内容和某些已知的不安全的网站匹配，
网络进程会给用户展示一个警告页面。Cross Origin Read Block，
保证一些敏感的跨站数据不会被发动给渲染进程。



### 创建一个渲染进程来绘制页面

在网络进程做完所有检查后，他会告诉UI线程所有数据我这边已经准备好了


UI线程在收到网络进程的反馈后，会为这网站创建一个渲染进程，来渲染界面


-chrome优化 

UI线程在通知网络进程发起网络请求的时候，其实是已经知道用户访问那个网站了

UI线程会主动的去寻找或创建一个渲染进程，节省了新建渲染进程的时间

-重定向
UI线程废弃掉刚才预创的渲染进程，重新给新的url创建一个渲染进程


### 提交导航

响应数据
渲染进程

都准备完毕了。

浏览器进程会通知渲染进程提交本次导航。

渲染进程收到命令，开始提交导航

提交完毕后，渲染进程会通知浏览器进程，导航已经提交

浏览器进程收到反馈后，认为此次导航借宿，开始文档加载阶段


tab的绘画历史，前进按钮，后退按钮也会被更新


### 加载完成

当导航提交完成之后，渲染进程开始着手加载资源以及渲染页面


load，渲染进程会通知浏览器进程，然后UI进程通知体质导航栏上的圈圈停止转动。




## 如果要导航到不同站点

无论导航到什么站点，能想到的肯定还是有导航的这些所有步骤


beforeunload

浏览器进程会询问渲染进程：

带有表单的页面，你在想刷新或者跳转到其他页面，或者关掉tab的时候，一般请求下回弹窗一个确认框

-小问题

为什么浏览器进程需要去问渲染进程，还有没有收尾工作

因为当前页面发生的一切，包括页面内的js，都是由渲染进程控制的，渲染进程内的js做了什么，浏览器进程根本不知道


### 如果重新发起的导航，是在页面内发起的？

比如页面内的js，location.href=xxx

渲染进程会自己先检查一下有没有注册beforeunload事件，如果没有的话，渲染进程会想浏览器进程发起一次导航请求

### 如果重新发起的导航，是不同的站点

会另起一个渲染进程来完成这次导航，当前的渲染进程会unload




## Service Worker场景下的导航

sw其实只是运行在渲染进程内的一些js代码


导航开始的时候，浏览器如何判断当前站点有没有对应sw缓存

sw在注册的手时候，还有一个作用域被记录下来



### 优化

针对没有注册的sw的情况，浏览器会执行导航预加载


## 渲染过程中，具体做了什么

1、构建DOM

渲染进程会收到HTML数据，主线程开始解析收到的文本信息，将其转化为DOM对象


```html
Hi<b>I am<i>Chrome</b>!</i>

``

处理后

```html

Hi<b>I am<i>Chrome</i></b><i>!</i>

```


2、子资源加载

除HTML意外的资源，图片，js，css等，会从缓存或者网络上获取


3、js会阻塞HTML的解析过程

HTML解析器在碰到script标签的时候，会停止HTML文档解析，转向js代码的加载 解析 执行

js中可能包含document.write(),这样的代码改变文档流的形状，也就是改变document，会使整个DOM对象发生根本的变化

script标签async defer，js脚本会进行一步加载。


<link rel='preload' href='xxx.png'>会告诉浏览器 当前这个资源肯定会被用到，请求尽早加载这个资源
由网络进程负责加载的，不会影响当前渲染



### 样式计算

css -> cssdom

主线程会解析页面的css从而确定每个dom阶段的计算样式，getComputedStyle(),font-size:10rem 100px


即使你没有自定义的css，每个dom节点还是会有自己的初始css

div p ul li h1 h2


### 布局

layout 

具体过程：
1、主线程会遍历刚刚构建的dom树，根据dom节点计算节点的计算样式计算出一个不拘束layout tree
2、布局树上每个节点都会有他在页面上的xy坐标，盒子padding 具体信息。布局树上只有那些可见的dom节点信息

如果一个节点设置了display:none,这个节点就不会出现在布局树上，
visibility:hidden,这个节点还是会出现在布局树上


### 绘制
 
绘制顺序

div z-index:1
div z-index:2
div z-index:0 ,先绘制这个节点

后绘制的页面会覆盖前面绘制的页面，层级效果






### 重排

尺寸和位置发生改变或者获取dom的属性就会引起重排

getBoundingClientRect()
getComputedStyle()

获取计算属性，会导致重新计算样式，



### 重绘


