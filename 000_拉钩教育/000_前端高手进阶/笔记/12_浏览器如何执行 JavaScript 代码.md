# 浏览器如何执行 JavaScript 代码

### 编译过程

css预处理器：

1、解析Paring
2、转换Transformation
3、代码生成Code Generation


javascript引擎：
1、解析
2、解释
3、优化


### 解析

1、词法分析

将javascript代码解析成一个个的令牌Token。
令牌类型各不相同，有关键字、标识符、符号、字符串。

2、语法分析
将令牌组装陈给一棵语法树AST



### 解释

 JavaScript 引擎是通过解释器 Ignition 将 AST 转换成字节码

  字节码是对机器码的一个抽象描述，相对于机器码而言，它的代码量更小，从而可以减少内存消耗。


### 优化

解释器在得到 AST 之后，会按需进行解释和执行，也就是说如果某个函数没有被调用，则不会去解释执行它。

在这个过程中解释器会将一些重复可优化的操作（比如类型判断）收集起来生成分析数据，
然后将生成的字节码和分析数据传给编译器 TurboFan，编译器会依据分析数据来生成高度优化的机器码。

优化后的机器码的作用和缓存很类似，当解释器再次遇到相同的内容时，就可以直接执行优化后的机器码。
当然优化后的代码有时可能会无法运行（比如函数参数类型改变），那么会再次反优化为字节码交给解释器。


Javascript
（词法分析）
令牌（Token）
（语法分析）
抽象语法树（AST）
（解释）
字节码  
（）
优化过的机器码
（优化）
机器码


### 内存管理

JavaScript 引擎的内存空间分为堆（Heap）和栈（Stack）



### 栈

栈是一个临时存储空间，主要存储局部变量和函数调用（对于全局表达式会创建匿名函数并调用）。


对于基本数据类型（String、Undefined、Null、Boolean、Number、BigInt、Symbol）的局部变量，会直接在栈中创建，
而对象数据类型局部变量会存储在堆中，栈中只存储它的引用地址，也就是我们常说的浅拷贝。
全局变量以及闭包变量也是只存储引用地址。总而言之栈中存储的数据都是轻量的。

对于函数，解释器创建了“调用栈”（Call Stack）来记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，
解释器会为被添加进的函数创建一个栈帧 （Stack Frame，这个栈帧用来保存函数的局部变量以及执行语句）并立即执行。
如果正在执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈并执行。一旦这个函数执行结束，
对应的栈帧也会被立即销毁。



### 尾调用

递归调用由于调用次数较多，同时每层函数调用都需要保存栈帧，所以通常是比较消耗内存的操作。
对递归的优化一般有两个思路，减少递归次数和使用尾调用。

尾调用（Tail Call）是指函数的最后一步返回另一个函数的调用。例如下面的代码中，函数 a() 返回了函数 b() 的调用。

返回缓存的函数调用结果，或者返回多个函数调用都不属于“尾调用”。


### 堆

堆空间存储的数据比较复杂，大致可以划分为下面 5 个区域：

代码区（Code Space）
Map 区(Map Space)
大对象区（Large Object Space）
新生代（New Space）
老生代（Old Space）


### 新生代

大多数的对象最开始都会被分配在新生代，该存储空间相对较小，只有几十 MB，分为两个空间：from 空间和 to 空间。

程序中声明的对象首先会被分配到 from 空间，当进行垃圾回收时，会先将 from 空间中存活的的对象（存活对象可以理解为被引用的对象）复制到 to 空间进行保存，对未存活的对象空间进行回收。当复制完成后，from 空间和 to 空间进行调换，to 空间会变为新的 from 空间，原来的 from 空间则变为 to 空间，这种算法称之为 “Scanvage”。


新生代的内存回收频率很高、速度也很快，但空间利用率较低，因为让一半的内存空间处于“闲置”状态。



### 老生代


新生代中多次回收仍然存活的对象会被转移到空间较大的老生代。
因为老生代空间较大，如果回收方式仍然采用 Scanvage 算法来频繁复制对象，那性能开销就太大了。

所以老生代采用的是另一种“标记清除”（Mark-Sweep）的方式来回收未存活的对象空间。